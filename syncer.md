---
layout: page
navid: navsyncer
title: LowlaDB Syncer
summary: The LowlaDB Syncer keeps track of modifications to documents and tells LowlaDB clients when they need to sync and what data needs updating.
---
<a name="Intro"></a>

## Introduction ##

<a name="Spec"></a>

## Spec ##
The LowlaDB client, syncer and adapter all communicate via a simple HTTP-based protocol. This section defines the parts of the protocol that the syncer implements.

<a name="SpecDefs"></a>

#### Definitions ####
<table>
	<tr><td>ID</td><td>A text identifier that uniquely identifies a document. IDs are generated by adapters and, for new records created remotely, by clients.</td></tr>
	<tr><td>Version</td><td>A text identifier for a particular version of a document. Versions are only ever compared for equality, they do not need to support any kind of ordering. The only requirement is that the version must change when a document changes. Typical implementations include
		<ul>
			<li>an increasing counter</li>
			<li>a hash of the document</li>
			<li>a timestamp</li>
		</ul>
		Versions are always generated by adapters.</td></tr>
	<tr><td>Sequence</td><td>An increasing counter maintained by the syncer to order modifications and identify changes that have occurred since a client last synced.</td></tr>
	<tr><td>ClientNs</td><td>Client namespace, i.e., the database and collection where a document should be stored on the client. This is expressed in the usual MongoDB form `db.collection` where collection may itself contain embedded periods.</td></tr>
</table>

<a name="SpecClient"></a>

#### Client ####
A LowlaDB client may request modifications starting from a particular sequence by issuing an HTTP GET request to the endpoint

```
/api/v1/changes?seq=<sequence>
```

The syncer will generate a response of the form

```javascript
{
  “atoms”: [
    { 
      “sequence”: <sequence>,
      “id”: “<id>”,
      “version”: “<version>”,
      “clientNs”: “<clientNs>”,
      “deleted”: true|false,
    },
    … 
  ],
  “sequence”: <sequence that client should use for next request>
}
```

##### Notes #####
* The `seq` argument is optional; if it is missing the syncer will only respond with the current sequence number.
* Sequence numbers are never negative and so a client can begin to populate an empty database by issuing a `changes` request with `seq=0`.
* For performance or scalability reasons, the syncer need not return *all* atoms since the requested sequence. However, it must return the atoms in sequence order beginning with the oldest (i.e., lowest sequence number.) It must then set the `sequence` property of the response appropriately so that the client can continue requesting atoms until it has received them all with no gaps. In situations where large numbers of modifications share the same sequence number, this may lead to some atoms being returned more than once. This is unavoidable without generating unique sequence numbers for every modification.
* The value of the `sequence` property will usually be higher than the maximum sequence value in any of the atoms. This is intentional and prevents the syncer from having to repeatedly return the most recent modification.


<a name="SpecAdapter"></a>

#### Adapter ####
A LowlaDB adapter is responsible for notifying the syncer whenever documents have been modified. The specifics of this will vary between platforms and even applications. Possible implementations include database triggers, replication log tailing and scheduled polling. In cases where data is only being modified by LowlaDB clients, the adapter can simply notify the syncer as it processes incoming documents from the client.

An adapter notifies the syncer of modifications by issuing an HTTP POST to the endpoint

```
/api/v1/update
```

with a request body of the form

```javascript
{
  “modified”: [
    {
      “id”: “<id>”,
      “version”: “<version>”,
      “clientNs”: “<clientNs>”
    },
    …
  “deleted”: [
    “<id1>”, “<id2>”, …
  ]
}
```

If the server accepts the notification, it will respond with

```
{
  “sequence”: <the current sequence of the syncer after importing the changes>
}
```

##### Notes #####
* If the adapter does not receive a success response from the syncer, it needs to retry the request.
* The syncer need not use the same sequence for all of the supplied modifications. The syncer attempts to balance the performance cost of generating new sequences against the performance cost of having large numbers of documents sharing the same sequence. In any case, the returned sequence will always be greater than or equal to the largest sequence used during the import.

## API ##
<a name="API"></a>
